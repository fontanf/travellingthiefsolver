#include "packingwhiletravellingsolver/instance.hpp"

#include "packingwhiletravellingsolver/instance_builder.hpp"

#include "optimizationtools/utils/utils.hpp"
#include "optimizationtools/containers/indexed_set.hpp"

using namespace packingwhiletravellingsolver;

std::ostream& Instance::print(
        std::ostream& os,
        int verbose) const
{
    if (verbose >= 1) {
        os
            << "Number of cities:  " << number_of_cities() << std::endl
            << "Number of items:   " << number_of_items() << std::endl
            << "Distance:          " << distance() << std::endl
            << "Capacity:          " << capacity() << std::endl
            << "Minimum speed:     " << speed_min_ << std::endl
            << "Maximum speed:     " << speed_max_ << std::endl
            << "Renting ratio:     " << renting_ratio_ << std::endl
            << "City weight:       " << city_weight() << std::endl
            << "Weight sum:        " << weight_sum_ << std::endl
            << "Weight ratio:      " << (double)weight_sum_ / capacity() << std::endl
            ;
    }

    if (verbose >= 2) {
        os << std::endl
            << std::setw(12) << "City"
            << std::setw(12) << "Distance"
            << std::setw(12) << "# items"
            << std::endl
            << std::setw(12) << "------"
            << std::setw(12) << "--------"
            << std::setw(12) << "-------"
            << std::endl;
        for (CityId city_id = 0;
                city_id < number_of_cities();
                ++city_id) {
            const City& city = this->city(city_id);
            os
                << std::setw(12) << city_id
                << std::setw(12) << city.distance
                << std::setw(12) << city.item_ids.size()
                << std::endl;
        }
    }

    if (verbose >= 2) {
        os << std::endl
            << std::setw(12) << "Item"
            << std::setw(12) << "City"
            << std::setw(12) << "Weight"
            << std::setw(12) << "Profit"
            << std::endl
            << std::setw(12) << "----"
            << std::setw(12) << "--------"
            << std::setw(12) << "------"
            << std::setw(12) << "------"
            << std::endl;
        for (ItemId item_id = 0;
                item_id < number_of_items();
                ++item_id) {
            const Item& item = this->item(item_id);
            os
                << std::setw(12) << item_id
                << std::setw(12) << item.city_id
                << std::setw(12) << item.weight
                << std::setw(12) << item.profit
                << std::endl;
        }
    }

    return os;
}

void Instance::write(
        std::string instance_path) const
{
    if (instance_path.empty())
        return;
    std::ofstream file(instance_path);
    if (!file.good()) {
        throw std::runtime_error(
                "Unable to open file \"" + instance_path + "\".");
    }

    file << "NAME: XXX" << std::endl;
    file << "COMMENT: generated by fontanf/travellingthiefsolver" << std::endl;
    file << "TYPE: TSP" << std::endl;
    file << "DIMENSION: " << number_of_cities() << std::endl;
    file << "MIN SPEED: " << speed_min_ << std::endl;
    file << "MAX SPEED: " << speed_max_ << std::endl;
    file << "RENTING RATIO: " << renting_ratio_ << std::endl;
    file << "NUMBER OF ITEMS: " << number_of_items() << std::endl;
    file << "CAPACITY OF KNAPSACK: " << capacity() << std::endl;
    file << "EDGE_WEIGHT_SECTION" << std::endl;
    for (CityId city_id = 0;
            city_id < number_of_cities();
            ++city_id) {
        file << city_id + 1 << " " << city(city_id).distance << std::endl;
    }
    file << "ITEMS SECTION (INDEX, PROFIT, WEIGHT, ASSIGNED NODE NUMBER): " << std::endl;
    for (ItemId item_id = 0;
            item_id < number_of_items();
            ++item_id) {
        const Item& item = this->item(item_id);
        file
            << item_id + 1 << " "
            << item.profit << " "
            << item.weight << " "
            << item.city_id + 1 << std::endl;
    }
    file << "EOF" << std::endl;
}

bool Instance::reduce_unprofitable_items()
{
    optimizationtools::IndexedSet unprofitable_items(number_of_items());

    for (ItemId item_id = 0; item_id < number_of_items(); ++item_id) {
        const Item& item = this->item(item_id);
        const City& city = this->city(item.city_id);
        double speed_after_without = speed_max_ - (double)(city.weight_from_start * (speed_max_ - speed_min_)) / capacity();
        double speed_after_with = speed_max_ - (double)((city.weight_from_start + item.weight) * (speed_max_ - speed_min_)) / capacity();
        Profit cost_without = renting_ratio() * (double)city.distance_to_end / speed_after_without;
        Profit cost_with = renting_ratio() * (double)city.distance_to_end / speed_after_with;
        Profit min_cost = cost_with - cost_without;
        if (item.profit <= min_cost)
            unprofitable_items.add(item_id);
    }

    if (unprofitable_items.empty())
        return false;

    UnreductionInfo new_unreduction_info;
    new_unreduction_info.original_instance = unreduction_info_.original_instance;

    // Update mandatory_sets.
    new_unreduction_info.mandatory_items = unreduction_info_.mandatory_items;
    // Create new instance and compute unreduction_operations.
    ItemId new_number_of_items = number_of_items() - unprofitable_items.size();
    InstanceBuilder new_instance_builder;
    new_instance_builder.add_cities(number_of_cities());
    new_unreduction_info.unreduction_operations = std::vector<ItemId>(new_number_of_items);
    for (CityId city_id = 0; city_id < number_of_cities(); ++city_id) {
        new_instance_builder.set_distance(city_id, city(city_id).distance);
        new_instance_builder.add_weight(city_id, city(city_id).weight);
    }
    new_instance_builder.set_minimum_speed(speed_min_);
    new_instance_builder.set_maximum_speed(speed_max_);
    new_instance_builder.set_renting_ratio(renting_ratio_);
    new_instance_builder.set_capacity(capacity_);

    // Add items.
    ItemId new_item_id = 0;
    for (auto it = unprofitable_items.out_begin();
            it != unprofitable_items.out_end();
            ++it) {
        ItemId item_id = *it;
        const Item& item = this->item(item_id);
        if (new_item_id == -1)
            continue;
        new_unreduction_info.unreduction_operations[new_item_id]
            = unreduction_info_.unreduction_operations[item_id];
        new_instance_builder.add_item(item.city_id, item.weight, item.profit);
        new_item_id++;
    }

    *this = new_instance_builder.build();
    unreduction_info_ = new_unreduction_info;
    //print(std::cout, 1);
    return true;
}

bool Instance::reduce_compulsory_items()
{
    optimizationtools::IndexedSet compulsory_items(number_of_items());

    if (weight_sum_ <= capacity()) {
        for (ItemId item_id = 0; item_id < number_of_items(); ++item_id) {
            const Item& item = this->item(item_id);
            const City& city = this->city(item.city_id);
            double speed_after_without = speed_max_ - (double)((weight_sum_ - item.weight) * (speed_max_ - speed_min_)) / capacity();
            double speed_after_with = speed_max_ - (double)(weight_sum_ * (speed_max_ - speed_min_)) / capacity();
            Profit cost_without = renting_ratio() * (double)city.distance_to_end / speed_after_without;
            Profit cost_with = renting_ratio() * (double)city.distance_to_end / speed_after_with;
            Profit max_cost = cost_with - cost_without;
            if (item.profit >= max_cost) {
                compulsory_items.add(item_id);
            }
        }
    }

    if (compulsory_items.empty())
        return false;

    UnreductionInfo new_unreduction_info;
    new_unreduction_info.original_instance = unreduction_info_.original_instance;

    // Update mandatory_sets.
    new_unreduction_info.mandatory_items = unreduction_info_.mandatory_items;
    // Create new instance and compute unreduction_operations.
    ItemId new_number_of_items = number_of_items() - compulsory_items.size();
    InstanceBuilder new_instance_builder;
    new_instance_builder.add_cities(number_of_cities());
    new_unreduction_info.unreduction_operations = std::vector<ItemId>(new_number_of_items);
    for (CityId city_id = 0; city_id < number_of_cities(); ++city_id) {
        new_instance_builder.set_distance(city_id, city(city_id).distance);
        new_instance_builder.add_weight(city_id, city(city_id).weight);
    }
    new_instance_builder.set_minimum_speed(speed_min_);
    new_instance_builder.set_maximum_speed(speed_max_);
    new_instance_builder.set_renting_ratio(renting_ratio_);
    new_instance_builder.set_capacity(capacity_);

    // Update mandatory_items.
    for (ItemId item_id: compulsory_items) {
        const Item& item = this->item(item_id);
        new_instance_builder.add_weight(item.city_id, item.weight);
        ItemId orig_item_id = unreduction_info_.unreduction_operations[item_id];
        new_unreduction_info.mandatory_items.push_back(orig_item_id);
    }
    // Add items.
    ItemId new_item_id = 0;
    for (auto it = compulsory_items.out_begin();
            it != compulsory_items.out_end();
            ++it) {
        ItemId item_id = *it;
        const Item& item = this->item(item_id);
        if (new_item_id == -1)
            continue;
        new_unreduction_info.unreduction_operations[new_item_id]
            = unreduction_info_.unreduction_operations[item_id];
        new_instance_builder.add_item(item.city_id, item.weight, item.profit);
        new_item_id++;
    }

    *this = new_instance_builder.build();
    unreduction_info_ = new_unreduction_info;
    //print(std::cout, 1);
    return true;
}

Instance Instance::reduce(ReductionParameters parameters) const
{
    // Initialize reduced instance.
    Instance instance_new = *this;
    instance_new.unreduction_info_ = UnreductionInfo();
    instance_new.unreduction_info_.original_instance = this;
    instance_new.unreduction_info_.unreduction_operations = std::vector<ItemId>(number_of_items());
    for (ItemId item_id = 0;
            item_id < number_of_items();
            ++item_id) {
        instance_new.unreduction_info_.unreduction_operations[item_id] = item_id;
    }

    for (Counter round_number = 0;
            round_number < parameters.maximum_number_of_rounds;
            ++round_number) {
        bool found = false;
        found |= instance_new.reduce_unprofitable_items();
        found |= instance_new.reduce_compulsory_items();
        if (!found)
            break;
    }

    instance_new.unreduction_info_.extra_profit = 0;
    for (ItemId orig_item_id: instance_new.unreduction_info_.mandatory_items)
        instance_new.unreduction_info_.extra_profit += item(orig_item_id).profit;

    return instance_new;
}

void packingwhiletravellingsolver::init_display(
        const Instance& instance,
        optimizationtools::Info& info)
{
    info.os()
        << "======================================" << std::endl
        << "       Packing while travelling       " << std::endl
        << "======================================" << std::endl
        << std::endl
        << "Instance" << std::endl
        << "--------" << std::endl;
    instance.print(info.os(), info.verbosity_level());
    info.os() << std::endl;
}
